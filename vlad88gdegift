-- –§–£–ù–ö–¶–ò–Ø –î–õ–Ø MUD ROLL –° –ü–û–ò–°–ö–û–ú –ë–õ–ò–ñ–ê–ô–®–ï–ì–û MUD
local function doMudRoll(region)
    print("=== –ù–ê–ß–ò–ù–ê–ï–ú MUD ROLL –î–õ–Ø " .. region:upper() .. " ===")
    
    local mudMission
    if region == 'Swamp Hollow' then
        mudMission = game:GetService('Players')[player.Name].PlayerGui.Data.Missions.RegionMissions["Swamp Hollow"].DistanceTravelled
    elseif region == 'Jungle' then
        mudMission = game:GetService('Players')[player.Name].PlayerGui.Data.Missions.RegionMissions.Jungle.DistanceTravelled
    else
        mudMission = game:GetService('Players')[player.Name].PlayerGui.Data.Missions.RegionMissions['Pride Rocks'].DistanceTravelled
    end

    if mudMission.Value then
        print("Mud Roll —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω!")
        return true
    end

    -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –∫ —Ç–æ—á–∫–µ Mud
    local mudPoint
    if region == 'Swamp Hollow' then
        mudPoint = swampHollowMudPoint
    elseif region == 'Jungle' then
        mudPoint = jungleMudPoint
    else
        mudPoint = prideRocksMudPoint
    end
    
    print("üìå –¢–ï–õ–ï–ü–û–†–¢–ê–¶–ò–Ø –ö MUD –¢–û–ß–ö–ï...")
    teleportTo(mudPoint)
    wait(2)

    -- –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ü–û–ò–°–ö–ê –ë–õ–ò–ñ–ê–ô–®–ï–ì–û MUD
    local function findNearestMud()
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            return nil
        end
        
        local playerPos = character.HumanoidRootPart.Position
        local nearestMud = nil
        local nearestDistance = math.huge
        
        -- –ò—â–µ–º –≤—Å–µ Mud –æ–±—ä–µ–∫—Ç—ã –≤ Interactions
        local interactions = workspace:FindFirstChild("Interactions")
        if interactions then
            local mudFolder = interactions:FindFirstChild("Mud")
            if mudFolder then
                for _, mudObject in pairs(mudFolder:GetChildren()) do
                    if mudObject:IsA("Part") or mudObject:IsA("MeshPart") then
                        local distance = (playerPos - mudObject.Position).Magnitude
                        if distance < nearestDistance then
                            nearestDistance = distance
                            nearestMud = mudObject
                        end
                    end
                end
            end
        end
        
        -- –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ Interactions, –∏—â–µ–º –ø–æ –≤—Å–µ–º—É workspace
        if not nearestMud then
            local allMuds = workspace:GetDescendants()
            for _, obj in pairs(allMuds) do
                if (obj:IsA("Part") or obj:IsA("MeshPart")) and string.lower(obj.Name):find("mud") then
                    local distance = (playerPos - obj.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestMud = obj
                    end
                end
            end
        end
        
        if nearestMud then
            print("‚úÖ –ù–∞–π–¥–µ–Ω –±–ª–∏–∂–∞–π—à–∏–π Mud: " .. nearestMud.Name .. " (—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: " .. math.floor(nearestDistance) .. ")")
        else
            print("‚ùå Mud –æ–±—ä–µ–∫—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        end
        
        return nearestMud
    end

    -- –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–π Mud
    local nearestMud = findNearestMud()
    if not nearestMud then
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ Mud –æ–±—ä–µ–∫—Ç")
        return false
    end

    -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –±–ª–∏–∂–µ –∫ Mud –æ–±—ä–µ–∫—Ç—É
    print("üìç –¢–ï–õ–ï–ü–û–†–¢–ê–¶–ò–Ø –ö –ë–õ–ò–ñ–ê–ô–®–ï–ú–£ MUD...")
    local mudCFrame = nearestMud.CFrame + Vector3.new(0, 0, 3) -- –°—Ç–∞–Ω–æ–≤–∏–º—Å—è —Ä—è–¥–æ–º, –∞ –Ω–µ –≤–Ω—É—Ç—Ä–∏
    teleportTo(mudCFrame)
    wait(1)

    -- –ò—Å–ø–æ–ª—å–∑—É–µ–º Mud 7 —Ä–∞–∑ –ø–æ–¥—Ä—è–¥
    print("üîÑ –ò–°–ü–û–õ–¨–ó–£–ï–ú MUD 7 –†–ê–ó...")
    for i = 1, 7 do
        if not running or mudMission.Value then
            break
        end
        
        pcall(function()
            local args = { nearestMud }
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Mud"):FireServer(unpack(args))
            print("üèûÔ∏è " .. region .. " Mud " .. i .. "/7")
        end)
        
        wait(1)
    end

    wait(3)
    
    if mudMission.Value then
        print("‚úÖ Mud Roll –í–´–ü–û–õ–ù–ï–ù!")
        return true
    else
        print("‚ùå Mud Roll –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º...")
        return false
    end
end

-- –£–ü–†–û–©–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –î–õ–Ø SWAMP HOLLOW (–µ—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–∞—è –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç)
local function doMudRollSwampHollowSimple()
    print("=== MUD ROLL –î–õ–Ø SWAMP HOLLOW (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–π) ===")
    
    local mudMission = game:GetService('Players')[player.Name].PlayerGui.Data.Missions.RegionMissions["Swamp Hollow"].DistanceTravelled

    if mudMission.Value then
        print("Mud Roll —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω!")
        return true
    end

    -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –∫ —Ç–æ—á–∫–µ Mud
    print("üìå –¢–ï–õ–ï–ü–û–†–¢–ê–¶–ò–Ø –ö MUD –¢–û–ß–ö–ï SWAMP HOLLOW...")
    teleportTo(swampHollowMudPoint)
    wait(2)

    -- –ü–æ–∏—Å–∫ –í–°–ï–• Mud –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –≤—ã–±–æ—Ä –±–ª–∏–∂–∞–π—à–µ–≥–æ
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local playerPos = character.HumanoidRootPart.Position
    local nearestMud = nil
    local nearestDistance = math.huge
    
    print("üîç –ü–û–ò–°–ö –í–°–ï–• MUD –û–ë–™–ï–ö–¢–û–í...")
    
    -- –ü–æ–∏—Å–∫ –≤–æ –≤—Å–µ–º workspace
    local allObjects = workspace:GetDescendants()
    for _, obj in pairs(allObjects) do
        if (obj:IsA("Part") or obj:IsA("MeshPart")) and string.lower(obj.Name):find("mud") then
            local distance = (playerPos - obj.Position).Magnitude
            print("–ù–∞–π–¥–µ–Ω Mud: " .. obj:GetFullName() .. " (—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: " .. math.floor(distance) .. ")")
            
            if distance < nearestDistance then
                nearestDistance = distance
                nearestMud = obj
            end
        end
    end
    
    if not nearestMud then
        print("‚ùå Mud –æ–±—ä–µ–∫—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!")
        return false
    end
    
    print("‚úÖ –í—ã–±—Ä–∞–Ω –±–ª–∏–∂–∞–π—à–∏–π Mud: " .. nearestMud:GetFullName() .. " (—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: " .. math.floor(nearestDistance) .. ")")
    
    -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –ø—Ä—è–º–æ –∫ Mud
    print("üìç –¢–ï–õ–ï–ü–û–†–¢–ê–¶–ò–Ø –ù–ï–ü–û–°–†–ï–î–°–¢–í–ï–ù–ù–û –ö MUD...")
    local mudCFrame = nearestMud.CFrame + Vector3.new(0, 3, 0) -- –ù–∞–¥ –æ–±—ä–µ–∫—Ç–æ–º
    teleportTo(mudCFrame)
    wait(1)

    -- –ò—Å–ø–æ–ª—å–∑—É–µ–º Mud 7 —Ä–∞–∑
    print("üîÑ –ò–°–ü–û–õ–¨–ó–£–ï–ú MUD 7 –†–ê–ó...")
    for i = 1, 7 do
        if not running or mudMission.Value then
            break
        end
        
        pcall(function()
            local args = { nearestMud }
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Mud"):FireServer(unpack(args))
            print("üèûÔ∏è Swamp Hollow Mud " .. i .. "/7 (—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: " .. math.floor((playerPos - nearestMud.Position).Magnitude) .. ")")
        end)
        
        wait(1)
    end

    wait(3)
    
    if mudMission.Value then
        print("‚úÖ Mud Roll –í–´–ü–û–õ–ù–ï–ù!")
        return true
    else
        print("‚ùå Mud Roll –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω")
        return false
    end
end
