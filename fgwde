local player = game:GetService("Players").LocalPlayer
local teleportDelay = 1 -- Задержка между телепортами (в секундах)

-- Функция для сбора валютных нод
local function collectCurrencyNodes()
    while true do
        wait(4)
        local nodes = workspace.Interactions.CurrencyNodes:GetChildren()
        for i = 1, math.min(150, #nodes) do
            wait(0.01)
            local args = {
                [1] = nodes[i]
            }
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("GetCurrencyNodeRemote"):FireServer(unpack(args))
        end
    end
end

-- Запускаем сбор валютных нод в отдельном потоке
coroutine.wrap(collectCurrencyNodes)()

local function findRandomCoin()
    -- Ищем все возможные монеты в игре
    local possibleCoinFolders = {
        workspace:FindFirstChild('Coins'),
        workspace:FindFirstChild('Currency'),
        workspace:FindFirstChild('Money'),
        workspace:FindFirstChild('Collectables'),
        workspace.Interactions:FindFirstChild('CurrencyNodes'),
    }

    local allCoins = {}

    -- Собираем все монеты из возможных папок
    for _, folder in pairs(possibleCoinFolders) do
        if folder then
            for _, item in pairs(folder:GetDescendants()) do
                -- Проверяем, является ли объект монетой
                if item:IsA('BasePart') and (item.Name:lower():find('coin') or item.Name:lower():find('money') or item.Name:lower():find('currency')) then
                    table.insert(allCoins, item)
                end
            end
        end
    end

    -- Если монеты найдены, возвращаем случайную
    if #allCoins > 0 then
        return allCoins[math.random(1, #allCoins)]
    else
        warn('Не найдено ни одной монеты для телепортации!')
        return nil
    end
end

-- Функция для телепортации ПОД монету
local function teleportUnderCoin(character, coin)
    if not character or not character:FindFirstChild('HumanoidRootPart') or not coin then
        return false
    end

    local humanoidRootPart = character.HumanoidRootPart
    local humanoid = character:FindFirstChildOfClass('Humanoid')
    
    -- Получаем позицию монеты
    local coinPosition = coin.Position
    
    -- Вычисляем позицию ПОД монетой (смещаем вниз по Y)
    local teleportPosition = coinPosition + Vector3.new(0, -5, 0)
    
    -- Создаем CFrame для телепортации (сохраняем текущее вращение)
    local newCFrame = CFrame.new(teleportPosition) * CFrame.Angles(0, humanoidRootPart.Orientation.Y, 0)
    
    -- Телепортируем персонажа
    humanoidRootPart.CFrame = newCFrame
    
    -- Добавляем небольшой прыжок для надежности
    if humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
    
    print('Телепортирован под монету: ' .. coin.Name)
    return true
end

-- Функция для проверки безопасной позиции
local function isSafePosition(position)
    -- Проверяем, не находится ли позиция под землей или в стене
    local rayOrigin = position + Vector3.new(0, 5, 0)
    local rayDirection = Vector3.new(0, -10, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {player.Character}
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    if raycastResult then
        -- Если есть поверхность ниже, позиция безопасна
        return true
    end
    
    return false
end

-- Основной цикл телепортации
while true do
    task.wait(teleportDelay)

    -- Проверяем, существует ли персонаж
    local character = player.Character
    if not character or not character:FindFirstChild('HumanoidRootPart') then
        character = player.CharacterAdded:Wait()
        -- Ждем, пока персонаж полностью загрузится
        repeat task.wait() until character:FindFirstChild('HumanoidRootPart')
    end

    -- Ищем случайную монету
    local targetCoin = findRandomCoin()
    if targetCoin and character and character:FindFirstChild('HumanoidRootPart') then
        -- Телепортируемся ПОД монету
        teleportUnderCoin(character, targetCoin)
    end
end

-- Дополнительно: функция для телепортации к ближайшей монете
local function findNearestCoin()
    local character = player.Character
    if not character or not character:FindFirstChild('HumanoidRootPart') then
        return nil
    end
    
    local playerPosition = character.HumanoidRootPart.Position
    local nearestCoin = nil
    local nearestDistance = math.huge
    
    -- Поиск среди всех возможных папок с монетами
    local possibleCoinFolders = {
        workspace:FindFirstChild('Coins'),
        workspace:FindFirstChild('Currency'),
        workspace:FindFirstChild('Money'),
        workspace:FindFirstChild('Collectables'),
        workspace.Interactions:FindFirstChild('CurrencyNodes'),
    }
    
    for _, folder in pairs(possibleCoinFolders) do
        if folder then
            for _, item in pairs(folder:GetDescendants()) do
                if item:IsA('BasePart') and (item.Name:lower():find('coin') or item.Name:lower():find('money') or item.Name:lower():find('currency')) then
                    local distance = (playerPosition - item.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestCoin = item
                    end
                end
            end
        end
    end
    
    return nearestCoin
end

-- Альтернативный цикл для телепортации к ближайшей монете (раскомментировать если нужно)
--[[
while true do
    task.wait(teleportDelay)
    
    local character = player.Character
    if not character or not character:FindFirstChild('HumanoidRootPart') then
        character = player.CharacterAdded:Wait()
        repeat task.wait() until character:FindFirstChild('HumanoidRootPart')
    end

    local nearestCoin = findNearestCoin()
    if nearestCoin then
        teleportUnderCoin(character, nearestCoin)
    end
end
--]]
