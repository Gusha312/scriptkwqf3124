local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local HttpService = game:GetService('HttpService')
local player = Players.LocalPlayer

-- –ù–ê–°–¢–†–û–ô–ö–ò
local traderName = 'dibrownuuak'
local SERVER_URL = 'http://v409755.hosted-by-vdsina.com:3000'  -- –í–∞—à —Å–µ—Ä–≤–µ—Ä –∑–∞–∫–∞–∑–æ–≤
local FILE_PATH = 'FluentSettings/orders.txt'
local REQUEST_INTERVAL = 1
local MAX_REQUESTS = 300
local CURRENCY_NAME = 'Shooms'
local MAX_CONCURRENT_TRADES = 5
local MAX_SHROOMS = 500000
local TOKEN_DELAY = 0.5
local SHROOMS_DELAY = 0.2
local CREATURE_DELAY = 2.5
local BETWEEN_ITEMS_DELAY = 1
local ORDER_CHECK_INTERVAL = 10
local ACCEPT_DELAY = 0.3
local FINAL_TIMER_VALUE = 1
local MAX_TIMER_VALUE = 5
local MIN_TIMER_VALUE = 3
local MAX_TRADE_ATTEMPTS = 300
local DEBUG_MODE = true

-- –¢—Ä–µ–∫–∏–Ω–≥ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç—Ä–µ–π–¥–æ–≤
local activeTrades = {}
local activeTradeCount = 0

-- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
local function log(message)
    if DEBUG_MODE then
        print('[DEBUG] ' .. os.date('%X') .. ' ' .. message)
    end
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É –∑–∞–∫–∞–∑–æ–≤
local function checkServer()
    local script = [[
        local url = "]]..SERVER_URL..[[/orders"
        local success, response = pcall(function()
            return game:HttpGet(url, false)
        end)
        return success and "‚úÖ –°–µ—Ä–≤–µ—Ä –¥–æ—Å—Ç—É–ø–µ–Ω" or "‚ùå –û—à–∏–±–∫–∞: "..tostring(response)
    ]]
    local status = loadstring(script)()
    log(status)
    return status:find("‚úÖ") ~= nil
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–∫–∞–∑–æ–≤ —Å —Å–µ—Ä–≤–µ—Ä–∞
local function getServerOrders()
    if not checkServer() then return {} end

    local script = [[
        local url = "]]..SERVER_URL..[[/orders?_="..tostring(tick())
        local success, response = pcall(function()
            return game:HttpGet(url, false)
        end)
        if not success then return nil, "HTTP_ERROR|"..tostring(response) end
        return response
    ]]

    local loadFunc = loadstring(script)
    if not loadFunc then
        log("‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ loadstring")
        return {}
    end

    local success, response = pcall(loadFunc)
    if not success then
        log("‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: "..tostring(response))
        return {}
    end

    log("üîç –û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞ ("..#tostring(response).." —Å–∏–º–≤–æ–ª–æ–≤)")
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–∫–∞–∑—ã –≤ —Ñ–∞–π–ª –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    if response and not response:match("^ERROR|") then
        writefile(FILE_PATH, response)
    end
    
    return response
end

-- –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
local function deleteServerOrder(order)
    local script = [[
        local url = "]]..SERVER_URL..[[/orders/"..game:GetService("HttpService"):UrlEncode("]]..order..[[")
        local success, response = pcall(function()
            return game:HttpGet(url, false)
        end)
        if not success then return "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: "..tostring(response) end
        if response ~= "OK" then return "‚ùå –°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª: "..tostring(response) end
        return "‚úÖ –£—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ"
    ]]
    return loadstring(script)()
end

-- –ß—Ç–µ–Ω–∏–µ –∑–∞–∫–∞–∑–æ–≤ (–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏ —Å–µ—Ä–≤–µ—Ä–∞)
local function readOrders()
    -- –ü–æ–ª—É—á–∞–µ–º –∑–∞–∫–∞–∑—ã —Å —Å–µ—Ä–≤–µ—Ä–∞
    local serverResponse = getServerOrders()
    
    -- –ß–∏—Ç–∞–µ–º –∏–∑ —Ñ–∞–π–ª–∞ (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
    if not isfile(FILE_PATH) then
        writefile(FILE_PATH, '')
        return {}
    end

    local content = readfile(FILE_PATH)
    local orders = {}

    for line in content:gmatch('[^\r\n]+') do
        local typ, nick, amount = line:match('^(%w+):([%w_]+):(%d+)$')
        local creatureTyp, creatureNick, creatureName, creatureAmount = line:match('^(creature):([%w_]+):([%w%s]+):(%d+)$')
        
        if typ and nick and amount then
            if not orders[nick] then
                orders[nick] = {
                    shrooms = 0,
                    revive = 0,
                    fullgrow = 0,
                    creatures = {},
                    rawLines = {},
                }
            end

            if typ == 'shrooms' then
                orders[nick].shrooms = orders[nick].shrooms + tonumber(amount)
            elseif typ == 'revive' then
                orders[nick].revive = orders[nick].revive + tonumber(amount)
            elseif typ == 'fullgrow' then
                orders[nick].fullgrow = orders[nick].fullgrow + tonumber(amount)
            end

            table.insert(orders[nick].rawLines, line)
        elseif creatureTyp and creatureNick and creatureName and creatureAmount then
            if not orders[creatureNick] then
                orders[creatureNick] = {
                    shrooms = 0,
                    revive = 0,
                    fullgrow = 0,
                    creatures = {},
                    rawLines = {},
                }
            end

            orders[creatureNick].creatures[creatureName] = (orders[creatureNick].creatures[creatureName] or 0) + tonumber(creatureAmount)
            table.insert(orders[creatureNick].rawLines, line)
        end
    end

    return orders
end

-- –£–¥–∞–ª–µ–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤ (–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏ —Å–µ—Ä–≤–µ—Ä–∞)
local function removeCompletedOrders(rawLines)
    -- –£–¥–∞–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
    for _, line in ipairs(rawLines) do
        log(deleteServerOrder(line))
        wait(0.3)
    end
    
    -- –£–¥–∞–ª—è–µ–º –≤ —Ñ–∞–π–ª–µ (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
    if not isfile(FILE_PATH) then return false end

    local content = readfile(FILE_PATH)
    local lines = {}
    for line in content:gmatch('[^\r\n]+') do
        table.insert(lines, line)
    end

    local toRemove = {}
    for _, line in ipairs(rawLines) do
        toRemove[line] = true
    end

    local newContent = {}
    for _, line in ipairs(lines) do
        if not toRemove[line] then
            table.insert(newContent, line)
        end
    end

    writefile(FILE_PATH, table.concat(newContent, '\n'))
    return true
end

-- –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –≤—ã–∑–æ–≤—ã Remote
local function safeFireRemote(remote, ...)
    if not remote or not remote:IsA('RemoteEvent') then
        return false
    end
    local args = { ... }
    return pcall(function()
        remote:FireServer(unpack(args))
    end)
end

local function safeInvokeRemote(remote, ...)
    if not remote or not remote:IsA('RemoteFunction') then
        return false
    end
    local args = { ... }
    return pcall(function()
        return remote:InvokeServer(unpack(args))
    end)
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤ –≤ —Å–ª–æ—Ç–∞—Ö 13-20
local function verifyCreaturesInTrade(expectedCreatures)
    wait(2)
    
    local offersFrame = player.PlayerGui.TradeGui.ContainerFrame.Yours.OffersFrame.ScrollingFrame
    if not offersFrame then
        warn("–ù–µ –Ω–∞–π–¥–µ–Ω —Ñ—Ä–µ–π–º —Å –ø—Ä–µ–¥–º–µ—Ç–∞–º–∏!")
        return false
    end

    local children = offersFrame:GetChildren()
    local foundAll = true
    
    for creatureName in pairs(expectedCreatures) do
        local found = false
        
        for slot = 13, 20 do
            if children[slot] then
                local child = children[slot]
                if child:FindFirstChild("ItemFrame") then
                    local itemFrame = child.ItemFrame
                    if itemFrame:FindFirstChild("NameLabel") then
                        if itemFrame.NameLabel.Text == creatureName then
                            log("–ù–∞–π–¥–µ–Ω–æ —Å—É—â–µ—Å—Ç–≤–æ "..creatureName.." –≤ —Å–ª–æ—Ç–µ "..slot)
                            found = true
                            break
                        end
                    end
                end
            end
        end
        
        if not found then
            warn("–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å—É—â–µ—Å—Ç–≤–æ: "..creatureName)
            foundAll = false
        end
    end

    return foundAll
end

-- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤
local function addCreatures(tradeRemote, creatures)
    for creatureName, amount in pairs(creatures) do
        local args = {
            "AddTradeItem",
            {
                Overwrite = true,
                ItemType = "Creatures",
                Name = creatureName,
                Amount = amount
            }
        }
        
        log("–î–æ–±–∞–≤–ª—è—é —Å—É—â–µ—Å—Ç–≤–æ: "..creatureName.." ("..amount.." —à—Ç.)")
        
        local success, response = safeInvokeRemote(tradeRemote, unpack(args))
        if not success then
            warn("–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è: "..tostring(response))
            return false
        end
        
        wait(1.5)
        for slot = 13, 20 do
            local child = player.PlayerGui.TradeGui.ContainerFrame.Yours.OffersFrame.ScrollingFrame:GetChildren()[slot]
            if child and child.ItemFrame and child.ItemFrame.NameLabel then
                log("–°–ª–æ—Ç "..slot..": "..child.ItemFrame.NameLabel.Text)
            end
        end
        
        wait(CREATURE_DELAY - 1.5)
    end
    return true
end

-- –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç—Ä–µ–π–¥–∞
local function confirmTrade(tradeRemote)
    log("–ù–∞—á–∏–Ω–∞—é –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç—Ä–µ–π–¥–∞...")
    local attempts = 0
    
    while attempts < 100 do
        attempts = attempts + 1
        
        safeInvokeRemote(tradeRemote, 'AcceptTrade')
        
        local timerText = player.PlayerGui.TradeGui.ContainerFrame.TimerLabel.Text
        local currentTimer = tonumber(timerText)
        
        if currentTimer == FINAL_TIMER_VALUE then
            log("–¢—Ä–µ–π–¥ —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!")
            return true
        end
        
        wait(ACCEPT_DELAY)
    end
    
    warn("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ç—Ä–µ–π–¥ –ø–æ—Å–ª–µ 100 –ø–æ–ø—ã—Ç–æ–∫")
    return false
end

-- –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ç—Ä–µ–π–¥–∞
local function processTrade(nick, shrooms, revive, fullgrow, creatures, rawLines)
    if activeTrades[nick] or activeTradeCount >= MAX_CONCURRENT_TRADES then
        return
    end

    activeTrades[nick] = true
    activeTradeCount = activeTradeCount + 1

    log('\n–ù–∞—á–∞–ª–æ —Ç—Ä–µ–π–¥–∞ —Å ' .. nick)
    local target = Players:FindFirstChild(nick) or Players:GetPlayerByUserId(tonumber(nick) or 0)
    if not target then
        activeTrades[nick] = nil
        activeTradeCount = activeTradeCount - 1
        return
    end

    local tradeAttempts = 0
    local tradeCompleted = false

    while tradeAttempts < MAX_TRADE_ATTEMPTS and not tradeCompleted do
        tradeAttempts = tradeAttempts + 1
        log("–ü–æ–ø—ã—Ç–∫–∞ —Ç—Ä–µ–π–¥–∞ #"..tradeAttempts)
        
        local requestRemote = player.Remotes.TradeRequestRemote
        if not requestRemote then
            warn("–ù–µ –Ω–∞–π–¥–µ–Ω TradeRequestRemote")
            break
        end

        player.PlayerGui.TradeGui.Enabled = false
        safeFireRemote(requestRemote, 'SendRequest', target)

        local tradeGui
        for i = 1, MAX_REQUESTS do
            tradeGui = player.PlayerGui:FindFirstChild('TradeGui')
            if tradeGui then break end
            wait(REQUEST_INTERVAL)
        end

        if not tradeGui then
            warn('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å TradeGui')
            break
        end

        player.PlayerGui.TradeGui.Enabled = true
        local tradeRemote = ReplicatedStorage.Remotes:FindFirstChild(traderName .. '-' .. nick .. 'TradeRemote')
        if not tradeRemote then
            warn("–ù–µ –Ω–∞–π–¥–µ–Ω TradeRemote –¥–ª—è "..nick)
            break
        end

        -- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –≤ —Ç—Ä–µ–π–¥
        if revive and revive > 0 then
            log("–î–æ–±–∞–≤–ª—è—é revive —Ç–æ–∫–µ–Ω—ã: "..revive)
            safeInvokeRemote(tradeRemote, 'AddTradeItem', {
                ItemType = 'Tokens',
                Name = 'CreatureReviveToken',
                Amount = revive,
            })
            wait(TOKEN_DELAY)
        end

        if fullgrow and fullgrow > 0 then
            log("–î–æ–±–∞–≤–ª—è—é fullgrow —Ç–æ–∫–µ–Ω—ã: "..fullgrow)
            safeInvokeRemote(tradeRemote, 'AddTradeItem', {
                ItemType = 'Tokens',
                Name = 'FullGrowToken',
                Amount = fullgrow,
            })
            wait(TOKEN_DELAY)
        end

        if shrooms and shrooms > 0 then
            log("–î–æ–±–∞–≤–ª—è—é –≥—Ä–∏–±—ã: "..math.min(shrooms, MAX_SHROOMS))
            safeInvokeRemote(tradeRemote, 'AddTradeItem', {
                ItemType = 'Currency',
                Name = CURRENCY_NAME,
                Amount = math.min(shrooms, MAX_SHROOMS),
            })
            wait(SHROOMS_DELAY)
        end

        if creatures and next(creatures) then
            log("–î–æ–±–∞–≤–ª—è—é —Å—É—â–µ—Å—Ç–≤:")
            for name, amount in pairs(creatures) do
                log(name..": "..amount)
            end
            
            if not addCreatures(tradeRemote, creatures) then
                warn("–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—É—â–µ—Å—Ç–≤")
                player.PlayerGui.TradeGui.Enabled = false
                wait(1)
                continue
            end
            
            if not verifyCreaturesInTrade(creatures) then
                warn("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞")
                player.PlayerGui.TradeGui.Enabled = false
                wait(1)
                continue
            end
        end

        tradeCompleted = confirmTrade(tradeRemote)
        
        if tradeCompleted then
            removeCompletedOrders(rawLines)
        else
            warn("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ç—Ä–µ–π–¥")
            player.PlayerGui.TradeGui.Enabled = false
            wait(1)
        end
    end

    activeTrades[nick] = nil
    activeTradeCount = activeTradeCount - 1
    player.PlayerGui.TradeGui.Enabled = false
    log("–¢—Ä–µ–π–¥ —Å "..nick.." –∑–∞–≤–µ—Ä—à–µ–Ω")
end

-- –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
while wait(ORDER_CHECK_INTERVAL) do
    local orders = readOrders()
    local orderCount = 0
    for _ in pairs(orders) do orderCount = orderCount + 1 end
    log("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫–∞–∑–æ–≤. –ù–∞–π–¥–µ–Ω–æ: "..orderCount)
    
    for nick, data in pairs(orders) do
        if activeTradeCount < MAX_CONCURRENT_TRADES and not activeTrades[nick] then
            log("\n–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫–∞–∑–∞ –¥–ª—è "..nick)
            log("–ì—Ä–∏–±—ã: "..(data.shrooms or 0))
            log("Revive: "..(data.revive or 0))
            log("FullGrow: "..(data.fullgrow or 0))
            if data.creatures then
                for name, amount in pairs(data.creatures) do
                    log("–°—É—â–µ—Å—Ç–≤–æ "..name..": "..amount)
                end
            end
            
            coroutine.wrap(processTrade)(
                nick,
                data.shrooms,
                data.revive,
                data.fullgrow,
                data.creatures,
                data.rawLines
            )
            wait(1.5)
        end
    end
end
