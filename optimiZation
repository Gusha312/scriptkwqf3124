-- Ультра-оптимизированный скрипт для Roblox
-- Автор: Абсолютный оптимизатор

local _G = _G
local table = table
local math = math
local string = string
local Vector3 = Vector3
local CFrame = CFrame
local Instance = Instance
local task = task
local table_insert = table.insert
local table_remove = table.remove
local math_floor = math.floor
local math_random = math.random
local math_clamp = math.clamp

-- Кэширование часто используемых объектов
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

-- Локальные переменные для максимальной производительности
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")
local camera = Workspace.CurrentCamera

-- Константы
local UPDATE_RATE = 1/30
local MAX_OBJECTS = 100
local OPTIMIZATION_THRESHOLD = 0.016

-- Пулы объектов для избежания создания/удаления
local objectPool = {}
local activeObjects = {}

-- Предварительное создание объектов
local function PreallocateObjects()
    for i = 1, MAX_OBJECTS do
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Plastic
        part.Size = Vector3.new(1, 1, 1)
        part.Parent = nil
        objectPool[i] = part
    end
end

-- Получение объекта из пула
local function GetFromPool()
    if #objectPool > 0 then
        local obj = table_remove(objectPool)
        table_insert(activeObjects, obj)
        return obj
    end
    return nil
end

-- Возврат объекта в пул
local function ReturnToPool(obj)
    if obj then
        obj.Parent = nil
        for i, activeObj in ipairs(activeObjects) do
            if activeObj == obj then
                table_remove(activeObjects, i)
                break
            end
        end
        table_insert(objectPool, obj)
    end
end

-- Оптимизированный цикл обновления
local lastUpdate = 0
local function OptimizedUpdate(deltaTime)
    if deltaTime - lastUpdate < UPDATE_RATE then
        return
    end
    
    lastUpdate = deltaTime
    
    -- Минимальная логика в основном цикле
    for i = #activeObjects, 1, -1 do
        local obj = activeObjects[i]
        if obj then
            -- Простая трансформация для примера
            local newPosition = Vector3.new(
                math_random(-50, 50),
                math_random(-50, 50), 
                math_random(-50, 50)
            )
            obj.Position = newPosition
        end
    end
end

-- Оптимизированная проверка расстояния
local function FastDistanceSquared(pos1, pos2)
    local dx = pos2.X - pos1.X
    local dy = pos2.Y - pos1.Y
    local dz = pos2.Z - pos1.Z
    return dx*dx + dy*dy + dz*dz
end

-- LOD система (Level of Detail)
local function ShouldUpdateLOD(distance)
    return distance < 50 -- Обновляем только близкие объекты
end

-- Оптимизированный спавн объектов
local function OptimizedSpawn()
    local obj = GetFromPool()
    if obj then
        obj.Parent = Workspace
        obj.Position = Vector3.new(0, 5, 0)
    end
end

-- Основной цикл с защитой от лагов
local connection
local function StartOptimizedLoop()
    if connection then
        connection:Disconnect()
    end
    
    connection = RunService.Heartbeat:Connect(function(deltaTime)
        local startTime = tick()
        
        OptimizedUpdate(deltaTime)
        
        -- Автоматическое снижение нагрузки при лагах
        if tick() - startTime > OPTIMIZATION_THRESHOLD then
            UPDATE_RATE = math_clamp(UPDATE_RATE * 1.1, 1/60, 1/10)
        else
            UPDATE_RATE = math_clamp(UPDATE_RATE * 0.99, 1/60, 1/10)
        end
    end)
end

-- Очистка памяти
local function Cleanup()
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    for i = #activeObjects, 1, -1 do
        ReturnToPool(activeObjects[i])
    end
end

-- Инициализация
local function Initialize()
    PreallocateObjects()
    StartOptimizedLoop()
    
    -- Оптимизированный спавн каждую секунду
    while true do
        task.wait(1)
        OptimizedSpawn()
    end
end

-- Запуск с обработкой ошибок
local success, err = pcall(Initialize)
if not success then
    warn("Оптимизированный скрипт упал:", err)
    Cleanup()
end

-- Возвращаем функции для внешнего использования
return {
    Initialize = Initialize,
    Cleanup = Cleanup,
    OptimizedSpawn = OptimizedSpawn,
    GetActiveCount = function() return #activeObjects end
}
