local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local HttpService = game:GetService('HttpService')

local localPlayer = Players.LocalPlayer
local TELEGRAM_BOT_TOKEN = '8499812762:AAHgYFVkfvCi6HL3HetOcYHuuaDfxVUINT0'

-- –°–ø–∏—Å–æ–∫ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö —Å—É—â–µ—Å—Ç–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
local ALLOWED_CREATURES = {
    'Asilvestrela',
    'Moluna',
    'Starlit',
    'Voletexius',
    'Elarickkeir',
    'Empiterium',
    'Erridea',
    'Eskarlor',
    'Golgaroth',
    'Jhiggo-Jangl',
    'Leurimess',
}

-- –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ update_id
local lastUpdateId = 0

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–∏–∑–±–µ–≥–∞–µ–º –ø—Ä–æ–±–ª–µ–º —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π)
local function safePrint(message)
    -- –ó–∞–º–µ–Ω—è–µ–º —Ä—É—Å—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ –∞–Ω–∞–ª–æ–≥–∏ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π
    local safeMessage = message
        :gsub("üìù", "[LOAD]")
        :gsub("üîÑ", "[RESET]")
        :gsub("ü§ñ", "[BOT]")
        :gsub("üîç", "[REQUEST]")
        :gsub("üì≠", "[NO MSG]")
        :gsub("‚úÖ", "[SUCCESS]")
        :gsub("‚ùå", "[ERROR]")
        :gsub("üì©", "[MESSAGE]")
        :gsub("üìä", "[STATS]")
        :gsub("üõí", "[BUY]")
        :gsub("üíæ", "[SAVE]")
        :gsub("üë§", "[PLAYER]")
        :gsub("üçÑ", "[MUSHROOMS]")
        :gsub("üêâ", "[CREATURES]")
        :gsub("ü™ô", "[TOKENS]")
    
    -- –û—Å–Ω–æ–≤–Ω—ã–µ —Ä—É—Å—Å–∫–∏–µ —Å–ª–æ–≤–∞ –∑–∞–º–µ–Ω—è–µ–º –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ
    safeMessage = safeMessage
        :gsub("–ó–∞–≥—Ä—É–∂–µ–Ω", "Loaded")
        :gsub("—Å–±—Ä–æ—à–µ–Ω", "reset")
        :gsub("–∑–∞–ø—É—â–µ–Ω", "started")
        :gsub("—Å–ª—É—à–∞–µ—Ç", "listening")
        :gsub("–∫–æ–º–∞–Ω–¥—ã", "commands")
        :gsub("–ó–∞–ø—Ä–æ—Å", "Request")
        :gsub("–æ—à–∏–±–∫–∞", "error")
        :gsub("–ü–æ–ª—É—á–µ–Ω–æ", "Received")
        :gsub("—Å–æ–æ–±—â–µ–Ω", "message")
        :gsub("–æ—Ç", "from")
        :gsub("–°–æ—Ö—Ä–∞–Ω–µ–Ω", "Saved")

    print(safeMessage)
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ update_id
local function loadLastUpdateId()
    return 0 -- –í—Å–µ–≥–¥–∞ –Ω–∞—á–∏–Ω–∞–µ–º —Å 0
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ update_id
local function saveLastUpdateId(updateId)
    lastUpdateId = updateId
end

-- –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π update_id –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
lastUpdateId = loadLastUpdateId()
safePrint("Loaded lastUpdateId: " .. lastUpdateId)

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤
local function isCreatureAllowed(creatureName)
    for _, allowedCreature in ipairs(ALLOWED_CREATURES) do
        if creatureName == allowedCreature then
            return true
        end
    end
    return false
end

-- –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram
local function sendToTelegram(chat_id, message)
    local url = 'https://api.telegram.org/bot' .. TELEGRAM_BOT_TOKEN .. '/sendMessage'

    local success, response = pcall(function()
        return request({
            Url = url,
            Method = 'POST',
            Headers = {
                ['Content-Type'] = 'application/json',
            },
            Body = HttpService:JSONEncode({
                chat_id = chat_id,
                text = message,
                parse_mode = 'HTML',
            }),
        })
    end)

    if success then
        safePrint("Message sent to Telegram")
        return true
    else
        safePrint("Error sending to Telegram: " .. tostring(response))
        return false
    end
end

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram
local function checkTelegramMessages()
    local url = 'https://api.telegram.org/bot' .. TELEGRAM_BOT_TOKEN .. '/getUpdates?offset=' .. (lastUpdateId + 1)

    safePrint("Request to Telegram API: offset=" .. (lastUpdateId + 1))

    local success, response = pcall(function()
        return request({
            Url = url,
            Method = 'GET',
        })
    end)

    if not success then
        safePrint("HTTP request error: " .. tostring(response))
        return {}
    end

    if not response or not response.Body then
        safePrint("Empty server response")
        return {}
    end

    if response.Body == "" or response.Body == "{}" then
        safePrint("No new messages (empty response)")
        return {}
    end

    -- –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON
    local ok, data = pcall(function()
        return HttpService:JSONDecode(response.Body)
    end)

    if not ok then
        safePrint("JSON parsing error")
        return {}
    end

    if not data then
        safePrint("Empty data after parsing")
        return {}
    end

    if data.ok == false then
        safePrint("Telegram API error: " .. tostring(data.description))
        return {}
    end

    if not data.ok or not data.result then
        safePrint("Invalid response format from Telegram")
        return {}
    end

    if #data.result == 0 then
        safePrint("No new messages (empty result)")
        return {}
    end

    safePrint("Received " .. #data.result .. " new messages")
    
    -- –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π update_id
    local maxUpdateId = lastUpdateId
    for _, update in ipairs(data.result) do
        if update.update_id > maxUpdateId then
            maxUpdateId = update.update_id
        end
    end
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π update_id
    if maxUpdateId > lastUpdateId then
        saveLastUpdateId(maxUpdateId)
        safePrint("Saved new lastUpdateId: " .. maxUpdateId)
    end

    return data.result
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å—É—â–µ—Å—Ç–≤
local function getCreaturesData(dataTable, includeZeros)
    local result = {}

    if dataTable then
        for _, value in pairs(dataTable:GetChildren()) do
            if isCreatureAllowed(value.Name) then
                if value:IsA('IntValue') or value:IsA('NumberValue') then
                    if includeZeros or value.Value > 0 then
                        result[value.Name] = value.Value
                    end
                elseif value:IsA('BoolValue') and (value.Value or includeZeros) then
                    result[value.Name] = value.Value and '‚úì' or '‚úó'
                end
            end
        end
    end

    return result
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤
local function getTokensData(dataTable)
    local result = {}

    if dataTable then
        for _, value in pairs(dataTable:GetChildren()) do
            if value:IsA('IntValue') or value:IsA('NumberValue') then
                if value.Value > 0 then
                    result[value.Name] = value.Value
                end
            elseif value:IsA('BoolValue') and value.Value then
                result[value.Name] = '‚úì'
            end
        end
    end

    return result
end

-- –§—É–Ω–∫—Ü–∏—è —Å–±–æ—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
local function collectStats()
    local stats = {
        mushrooms = localPlayer.Data.Coins.Value,
        creatures = getCreaturesData(localPlayer.Data.Unlocks, true),
        tokens = getTokensData(localPlayer.Data.Items),
    }
    return stats
end

-- –§—É–Ω–∫—Ü–∏—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
local function formatStats(stats)
    local message = '<b>Account Statistics:</b>\n\n'
    message = message .. '<b>Player:</b> ' .. localPlayer.Name .. '\n'
    message = message .. '<b>Mushrooms:</b> ' .. stats.mushrooms .. '\n\n'

    -- –°—É—â–µ—Å—Ç–≤–∞
    if next(stats.creatures) then
        message = message .. '<b>Creatures:</b>\n'
        for name, value in pairs(stats.creatures) do
            if type(value) == 'number' then
                message = message .. '‚Ä¢ ' .. name .. ': ' .. tostring(value) .. '\n'
            else
                message = message .. '‚Ä¢ ' .. name .. ': ' .. value .. '\n'
            end
        end
        message = message .. '\n'
    else
        message = message .. '<b>Creatures:</b> No data for specified creatures\n\n'
    end

    -- –¢–æ–∫–µ–Ω—ã
    if next(stats.tokens) then
        message = message .. '<b>Tokens:</b>\n'
        for name, value in pairs(stats.tokens) do
            message = message .. '‚Ä¢ ' .. name .. ': ' .. tostring(value) .. '\n'
        end
    else
        message = message .. '<b>Tokens:</b> No tokens\n'
    end

    return message
end

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–∫—É–ø–∫–∏ —Ç–æ–∫–µ–Ω–æ–≤
local function buyTokens(tokenName, amount)
    local purchaseRemote = ReplicatedStorage:WaitForChild('Remotes'):WaitForChild('PurchaseItemRemote')
    local args = { tokenName }
    local successCount = 0
    local failedCount = 0

    for i = 1, amount do
        local success, result = pcall(function()
            return purchaseRemote:InvokeServer(unpack(args))
        end)

        if success then
            successCount = successCount + 1
        else
            failedCount = failedCount + 1
            if failedCount <= 3 then
                safePrint("Error buying token " .. tokenName .. ": " .. tostring(result))
            end
        end
    end

    safePrint("Bought tokens " .. tokenName .. ": " .. successCount .. "/" .. amount)
    return successCount, failedCount
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–±—Ä–æ—Å–∞ lastUpdateId
local function resetLastUpdateId()
    lastUpdateId = 0
    saveLastUpdateId(0)
    safePrint("LastUpdateId reset to 0")
end

-- –°–±—Ä–∞—Å—ã–≤–∞–µ–º lastUpdateId –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
resetLastUpdateId()

safePrint("Telegram monitoring started! Bot is now listening to /stats and /buy commands")

-- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
while true do
    local success, messages = pcall(checkTelegramMessages)
    
    if success then
        for _, update in ipairs(messages) do
            if update.message and update.message.text then
                local text = update.message.text
                local chat_id = update.message.chat.id
                local username = update.message.from.username or update.message.from.first_name

                safePrint("Received message from " .. username .. ": " .. text)

                -- –ö–æ–º–∞–Ω–¥–∞ /stats
                if text:lower() == '/stats' then
                    safePrint("Received /stats command from " .. username)

                    local stats = collectStats()
                    local message = formatStats(stats)
                    sendToTelegram(chat_id, message)

                -- –ö–æ–º–∞–Ω–¥–∞ /buy
                elseif text:sub(1, 1) == '/' and text:sub(1, 5):lower() == '/buy ' then
                    safePrint("Received buy command from " .. username)

                    local parts = {}
                    for part in text:gmatch('%S+') do
                        table.insert(parts, part)
                    end

                    if #parts >= 3 then
                        local tokenName = parts[2]
                        local amount = tonumber(parts[3])

                        if amount and amount > 0 then
                            sendToTelegram(chat_id, '<b>Starting purchase...</b>\nToken: ' .. tokenName .. '\nAmount: ' .. amount)

                            local boughtCount, failedCount = buyTokens(tokenName, amount)

                            local resultMessage = '<b>Purchase completed!</b>\n'
                            resultMessage = resultMessage .. 'Token: ' .. tokenName .. '\n'
                            resultMessage = resultMessage .. 'Requested: ' .. amount .. '\n'
                            resultMessage = resultMessage .. 'Successfully bought: ' .. boughtCount .. '\n'

                            if failedCount > 0 then
                                resultMessage = resultMessage .. 'Failed to buy: ' .. failedCount .. '\n'
                            end

                            sendToTelegram(chat_id, resultMessage)
                        else
                            sendToTelegram(chat_id, '<b>Error!</b>\nInvalid amount. Use: /buy TokenName Amount')
                        end
                    else
                        sendToTelegram(chat_id, '<b>Format error!</b>\nUse: /buy TokenName Amount\nExample: /buy RandomStoredCreatureToken 100')
                    end
                
                -- –ö–æ–º–∞–Ω–¥–∞ /reset –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                elseif text:lower() == '/reset' then
                    resetLastUpdateId()
                    sendToTelegram(chat_id, "LastUpdateId reset. Now I will receive all new messages.")
                end
            end
        end
    else
        safePrint("Error in checkTelegramMessages: " .. tostring(messages))
    end

    wait(3)
end
